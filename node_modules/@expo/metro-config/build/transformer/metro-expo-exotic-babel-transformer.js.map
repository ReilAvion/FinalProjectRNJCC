{"version":3,"file":"metro-expo-exotic-babel-transformer.js","sourceRoot":"","sources":["../../src/transformer/metro-expo-exotic-babel-transformer.ts"],"names":[],"mappings":";AAAA,qEAAqE;;AAErE,uEAA6E;AAC7E,mDAKyB;AACzB,+CAA4C;AAE5C,MAAM,gBAAgB,GAAa,CAAC,cAAc,CAAC,CAAC;AAEpD,8CAA8C;AAC9C,MAAM,iBAAiB,GAAG,mCAAmB,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC,CAAC;AAE5F,6DAA6D;AAC7D,8DAA8D;AAC9D,MAAM,2BAA2B,GAAG,mCAAmB,CAAC;IACtD,SAAS,EAAE;QACT,sBAAsB;QACtB,sHAAsH;QACtH,SAAS;QACT,qDAAqD;QACrD,oBAAoB;KACrB;IACD,OAAO,EAAE,gBAAgB;CAC1B,CAAC,CAAC;AAEH,MAAM,SAAS,GAAG,iDAAuB,CAAC;IACxC,4DAA4D;IAC5D,4FAA4F;IAC5F,WAAW,CAAC,EAAE,QAAQ,EAAE;QACtB,8DAA8D;QAC9D,OAAO,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpF,CAAC,CAAC,QAAQ;YACV,CAAC,CAAC,KAAK,CAAC;IACZ,CAAC;IAED,kEAAkE;IAClE,0EAA0E;IAC1E,KAAK,EAAE;QACL,0DAA0D;QAC1D;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,mCAAmB,CAAC,EAAE,SAAS,EAAE,CAAC,kBAAkB,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC;YACzF,SAAS,EAAE,iCAAO,CAAC,iBAAiB;YACpC,IAAI,EAAE,IAAI;SACX;QACD,qEAAqE;QACrE;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,wCAAwB,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC;YAC7D,SAAS,EAAE,iCAAO,CAAC,iBAAiB;YACpC,IAAI,EAAE,IAAI;SACX;QACD,iEAAiE;QACjE;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,iCAAiB,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC;YACtD,SAAS,EAAE,iCAAO,CAAC,UAAU;YAC7B,IAAI,EAAE,IAAI;SACX;QACD,gGAAgG;QAChG;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,2CAA2B,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC;YAChE,SAAS,EAAE,iCAAO,CAAC,kBAAkB;YACrC,IAAI,EAAE,IAAI;SACX;QACD,gGAAgG;QAChG,+EAA+E;QAC/E,yCAAyC;QACzC,+EAA+E;QAC/E,8DAA8D;QAC9D;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI;YAChB,SAAS,EAAE,iCAAO,CAAC,iBAAiB;SACrC;QACD,0EAA0E;QAC1E,wFAAwF;QACxF,oDAAoD;QACpD;YACE,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI;YAChB,SAAS,EAAE,iCAAO,CAAC,GAAG;SACvB;KACF;CACF,CAAC,CAAC;AAEH,MAAM,CAAC,OAAO,GAAG;IACf,SAAS;IACT,WAAW,EAAX,yBAAW;CACZ,CAAC","sourcesContent":["// Copyright 2021-present 650 Industries (Expo). All rights reserved.\n\nimport { createExoticTransformer, loaders } from './createExoticTransformer';\nimport {\n  createExpoMatcher,\n  createKnownCommunityMatcher,\n  createModuleMatcher,\n  createReactNativeMatcher,\n} from './createMatcher';\nimport { getCacheKey } from './getCacheKey';\n\nconst nodeModulesPaths: string[] = ['node_modules'];\n\n// Match any node modules, or monorepo module.\nconst nodeModuleMatcher = createModuleMatcher({ folders: nodeModulesPaths, moduleIds: [] });\n\n// Match node modules which are so oddly written that we must\n// transpile them with every possible option (most expensive).\nconst impossibleNodeModuleMatcher = createModuleMatcher({\n  moduleIds: [\n    // victory is too wild\n    // SyntaxError in ../../node_modules/victory-native/lib/components/victory-primitives/bar.js: Missing semicolon. (9:1)\n    'victory',\n    // vector icons has some hidden issues that break NCL\n    '@expo/vector-icons',\n  ],\n  folders: nodeModulesPaths,\n});\n\nconst transform = createExoticTransformer({\n  // Specify which rules to use on a per-file basis, basically\n  // this is used to determine which modules are node modules, and which are application code.\n  getRuleType({ filename }) {\n    // Is a node module, and is not one of the impossible modules.\n    return nodeModuleMatcher.test(filename) && !impossibleNodeModuleMatcher.test(filename)\n      ? 'module'\n      : 'app';\n  },\n\n  // Order is very important, we use wild card matchers to transpile\n  // \"every unhandled node module\" and \"every unhandled application module\".\n  rules: [\n    // Match bob compiler modules, use the passthrough loader.\n    {\n      type: 'module',\n      test: createModuleMatcher({ moduleIds: ['.*/lib/commonjs/'], folders: nodeModulesPaths }),\n      transform: loaders.passthroughModule,\n      warn: true,\n    },\n    // Match React Native modules, convert them statically using sucrase.\n    {\n      type: 'module',\n      test: createReactNativeMatcher({ folders: nodeModulesPaths }),\n      transform: loaders.reactNativeModule,\n      warn: true,\n    },\n    // Match Expo SDK modules, convert them statically using sucrase.\n    {\n      type: 'module',\n      test: createExpoMatcher({ folders: nodeModulesPaths }),\n      transform: loaders.expoModule,\n      warn: true,\n    },\n    // Match known problematic modules, convert them statically using an expensive, dynamic sucrase.\n    {\n      type: 'module',\n      test: createKnownCommunityMatcher({ folders: nodeModulesPaths }),\n      transform: loaders.untranspiledModule,\n      warn: true,\n    },\n    // Pass through any unhandled node modules as passthrough, this is where the most savings occur.\n    // Ideally, you want your project to pass all node modules through this loader.\n    // This should be the last \"module\" rule.\n    // Message library authors and ask them to ship their modules as pre-transpiled\n    // commonjs, to improve the development speed of your project.\n    {\n      type: 'module',\n      test: () => true,\n      transform: loaders.passthroughModule,\n    },\n    // All application code should be transpiled with the user's babel preset,\n    // this is the most expensive operation but provides the most customization to the user.\n    // The goal is to use this as sparingly as possible.\n    {\n      test: () => true,\n      transform: loaders.app,\n    },\n  ],\n});\n\nmodule.exports = {\n  transform,\n  getCacheKey,\n};\n"]}